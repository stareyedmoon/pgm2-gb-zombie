Map tiles:
    0 - Empty                       Always pure black
    1 - Wall
    2 - Wall decoration             Example: Window
    3 - Edge
    4 - 
    5 - 
    6 - 
    7 - 
    8 - 
    9 - Stairs
    A - Path
    B - Ground                      Example: Grass
    C - 
    D - 
    E - Door
    F - Level transition

    Tiles 0-3 are collidable
    Tiles E-F are transitions
    These are likely to be reorganized in the future, and some of them will probably have their names changed.


    These get converted into various tiles depending on the surrounding tiles and the map type (such as interiors and exteriors)

    Level transition tiles (F) get the texture of their non-collidable neighbor (neighbors are checked in this order: Left, Up, Right, Down)

    TODO - Figure out how transition-type tiles should specify the destination
    TODO - Add something for trees and such


    If I add map compression, how should maps get loaded without decompressing every time it's accessed?
        Idea 1 - Split into 32x32 chunks (512 bytes) and load 4 at a time (for a total of 2 KiB),
                 replacing the ones which are loaded when needed, similarly to how tile loading works.
                 For this to be as quick as reasonably possible, it would probably have the sizes (in bytes)
                 of each chunk, and possibly each row of chunks.
    
                 Positives:
                    - Relatively easy to spread out over multiple banks if needed
                    - Fairly simple to implement
                 Negatives:
                    - It's likely that lag spikes will occur when loading new parts of the map
                 Neutrals:
                    - 2 KiB of RAM (25%) used at any given time for the map

                 Possible changes:
                    - Use 16x16 chunks and load 9 at a time, using less RAM (1152 bytes, or ~14%)
                      and having faster loading times, at the cost of more frequent loading, slightly
                      larger total compressed map size, and possibly slower tile loading due to
                      multiplication by a non-power-of-two.
                      + 12x12 chunks might also be a possibility, if we really run low on RAM
    
    If I add map compression, how should it work?
        Idea 1 - RLE encoded runlength:value
                 Runlength is encoded as follows:
                    0-7 ones followed by a zero specify the magnitude of the number.
                    [Magnitude] bits are read in, and get a 1 attached to the front,
                        and is then subtracted by one. The result is the runlength.
                    Note: This is the same format used by Pokemon sprite compression
                          for runlengths, which is the best universal code I've found
                          or managed to come up with for smaller numbers.
                 Value is the map tile

Encounters:
   When should enemies be encountered?
   What decides what kind of enemies are encountered?
   Other than the basic detail of being turn-based, how should encounters work?
      Perhaps, somewhat like Undertale, the amount of damage you deal and take
         are determined by your own skill?
